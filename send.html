<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sending page</title>
</head>
<style>
  body {
    background: black;
    overflow: hidden;
    font-family: Arial, Helvetica, sans-serif;
    color: white;
  }
  /*https://uiverse.io/barisdogansutcu/fuzzy-bullfrog-72*/
  button {
  padding: 17px 40px;
  border-radius: 50px;
  cursor: pointer;
  border: 0;
  background-color: white;
  box-shadow: rgb(0 0 0 / 5%) 0 0 8px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  font-size: 15px;
  transition: all 0.5s ease;
}

button:hover {
  letter-spacing: 3px;
  background-color: hsl(261deg 80% 48%);
  color: hsl(0, 0%, 100%);
  box-shadow: rgb(93 24 220) 0px 7px 29px 0px;
}

button:active {
  letter-spacing: 3px;
  background-color: hsl(261deg 80% 48%);
  color: hsl(0, 0%, 100%);
  box-shadow: rgb(93 24 220) 0px 0px 0px 0px;
  transform: translateY(10px);
  transition: 100ms;
}
</style>
<body>
    <button id='startButton'>Start</button>
    <button id='hangupButton'>Hang</button>
    <h1>LOCAL VIDEO</h1>
    <video id='localVideo' autoplay playsinline muted style="width: 80%; height: 80%; display: block; margin: 0 auto;"></video>
</body>
<script>

const startButton = document.getElementById('startButton');
const hangupButton = document.getElementById('hangupButton');
hangupButton.disabled = true;

const localVideo = document.getElementById('localVideo');

let peerConnection;
let localStream;

const params = new URLSearchParams(window.location.search);
const roomID = params.get('roomID');
// Simplement pour afficher l'URL sur laquelle on doit diffuser

const signaling = new WebSocket('wss://ws.tc-net.bzy.li'); // Serveur de signalement
signaling.onmessage = e => {
    if (!localStream) {
        console.log('Not ready yet'); // On a pas encore pu obtenir le flux vidéo de l'utilisateur qui veut diffuser 
        return;
    }
    const message = JSON.parse(e.data);  // Le type de message qui a été reçu
    switch (message.type) {
    case 'answer':                       // Le vidéoprojecteur/raspberry pi a répondu à l'offre de diffusion
      handleAnswer(message);
      break;
    case 'candidate':                    // Candidat ICE reçu
      handleCandidate(message);
      break;
    case 'ready':                        // Le raspbery pi/device est prêt à recevoir un flux
      if (peerConnection) {
        console.log('already in call, ignoring'); // on était déjà dans un appel donc on peut ignorer
        return;
      }
      console.log('Remote device ready');
      break;
    case 'bye':                         // Fin de l'appel WebRTC
      if (pc) {
        hangup();
      }
      break;
    default:
      console.log('unhandled', e);      // Message inconnu
      break;
  }
};

// Fonction pour récupérer le flux vidéo de l'utilisteur
startButton.onclick = async () => {
    localStream = await navigator.mediaDevices.getDisplayMedia({audio : false, video: true}); // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia
    localVideo.srcObject = localStream; // Affichage de la fenêtre capturé sur la page web

    startButton.disabled = true;
    hangupButton.disabled = false;

    signaling.send(JSON.stringify({type : 'ready', roomID : roomID})); // On prévient le signaling server qu'on est prêt
    makeCall();
};

hangupButton.onclick = async () => {
    hangup()
    signaling.send(JSON.stringify({type : 'bye', roomID : roomID})); // On prévient le signaling server qu'on raccroche
};

window.onbeforeunload = async () => {
    event.preventDefault();
    signaling.send(JSON.stringify({type : 'bye', roomID : roomID})); // On prévient le signaling server qu'on raccroche
    return null;
}

async function hangup() {
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
    startButton.disabled = false;
    hangupButton.disabled = true;
};

function createPeerConnection() {
    peerConnection = new RTCPeerConnection({iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, {urls: 'turn:turn.tc-net.bzy.li', username : 'test', credential :'test'}]});
    // API de WebRTC, on instancie l'object RTCPeerConnection avec éventuellement des serveurs stun et turn (pas forcément nécessaire sur Eduroam ?)
    peerConnection.oniceconnectionstatechange = () => console.log('ICE state:', peerConnection.iceConnectionState); // On affiche l'état de la découverte des pairs dans la console
    peerConnection.onicecandidate = e => { // On découvre un candidat ICE
        const message = {
            type : 'candidate',
            candidate : null, // Le candidat null correspond à la fin de la découverte des pairs en WebRTC
            roomID : roomID,
          };
        if (e.candidate) {
            message.candidate = e.candidate.candidate;
            message.sdpMid = e.candidate.sdpMid;
            message.sdpMLineIndex = e.candidate.sdpMLineIndex;
        }
        console.log(message);
        signaling.send(JSON.stringify(message)); // On partage ce candidat au Websocket (donc aux autres pairs)
    };
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream)); // On partage le flux vidéo en local vers la connection WebRTC
};

async function makeCall() {
  await createPeerConnection();

  const offer = await peerConnection.createOffer();
  signaling.send(JSON.stringify({type: 'offer', sdp: offer.sdp, roomID : roomID})); // On envoi l'offre de diffusion vers le websocket
  await peerConnection.setLocalDescription(offer);                                  // On met a jour la LocalDescription (ce qu'on va recevoir, ...)
}

async function handleAnswer(answer) {
  if (!peerConnection) {
    console.error('no peerconnection');
    return;
  }
  await peerConnection.setRemoteDescription(answer); // Ce qui va nous être envoyé
}

async function handleCandidate(candidate) {
  if (!peerConnection) {
    console.error('no peerconnection');
    return;
  }
  if (candidate.candidate) { // Si il y a effectivement un candidat dans ce qui nous a été envoyé (en gros pas null, donc pas la fin de la découverte)
    console.log('adding new candidate');
    const iceCandidate = new RTCIceCandidate({
        candidate: candidate.candidate,
        sdpMid: candidate.sdpMid,
        sdpMLineIndex: candidate.sdpMLineIndex
    });
    await peerConnection.addIceCandidate(iceCandidate); // On ajoute le candidat qui nous a été envoyé par un pair à notre liste de candidats.
  }
}
</script>
</html>
