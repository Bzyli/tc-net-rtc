<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Receiving page</title>
</head>
<style>
  body {
    background: black;
    overflow: hidden;
    font-family: Arial, Helvetica, sans-serif;
  }
  h1 {
    left: 0;
    line-height: 200px;
    margin-top: -100px;
    position: absolute;
    text-align: center;
    top: 50%;
    width: 100%;
    color:white;
}

/*https://uiverse.io/barisdogansutcu/fuzzy-bullfrog-72*/
button {
  padding: 17px 40px;
  border-radius: 50px;
  cursor: pointer;
  border: 0;
  background-color: white;
  box-shadow: rgb(0 0 0 / 5%) 0 0 8px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  font-size: 15px;
  transition: all 0.5s ease;
  margin : 2%;
}

</style>
<body>
    <h1 id='title'> Go to : </h1>
    <video id='remoteVideo' autoplay playsinline muted style="width: 100%; height: 100%; display: none;"></video>
</body>
<script>
const remoteVideo = document.getElementById('remoteVideo');
const title = document.getElementById('title');

let url = window.location.protocol + '//' + window.location.host;
const serverURL = window.location.host;

let peerConnection;

const params = new URLSearchParams(window.location.search);
const roomID = params.get('roomID');

title.innerHTML += " <button>" + url + "</button> and select <button> " + roomID + " </button> to start streaming !";

let signaling;
try {
  signaling = new WebSocket('wss://ws.' + serverURL);
} catch (e) {
  alert('exception: ' + e.message);
}



signaling.onopen = e => {
  signaling.send(JSON.stringify({type : 'ready', roomID : roomID}));
}

signaling.onmessage = e => {
    
    const message = JSON.parse(e.data);
    switch (message.type) {
        case 'offer':
      handleOffer(message);
      break;
    case 'answer':
      handleAnswer(message);
      break;
    case 'candidate':
      handleCandidate(message);
      break;
    case 'ready':
      // A second tab joined. This tab will initiate a call unless in a call already.
      if (peerConnection) {
        console.log('already in call, ignoring');
        return;
      }
      console.log('initiating connection');
      break;
    case 'bye':
      console.log('reloading');
      location.reload();
      break;
    default:
      console.log('unhandled', e);
      break;
  }
};

async function hangup() {
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
};

function createPeerConnection() {
    peerConnection = new RTCPeerConnection({iceServers: [{ urls: 'stun:stun.' + serverURL + ':3478' }, {urls: 'turn:turn' + serverURL + ':3478', username : 'tc-net', credential :'tc-net'}]});
    peerConnection.oniceconnectionstatechange = () => {
      const state = peerConnection.iceConnectionState;
      console.log('ICE state:', state);
      if (state === "failed" || state === "disconnected" || state === "closed") {
        location.reload();
      }
    }
    peerConnection.onicecandidate = e => {
        const message = {
            type : 'candidate',
            candidate : null,
            roomId : roomID,
        };
        if (e.candidate) {
            message.candidate = e.candidate.candidate;
            message.sdpMid = e.candidate.sdpMid;
            message.sdpMLineIndex = e.candidate.sdpMLineIndex;
        }
        console.log(message);
        signaling.send(JSON.stringify(message));
    };
    peerConnection.ontrack = e => { // Quand on reçoit le flux avec WebRTC
      title.style.display= 'none';
      remoteVideo.style.display = 'inline';
      remoteVideo.srcObject = e.streams[0]; // On met le flux vidéo dans notre tag html vidéo
    }
};

async function handleOffer(offer) {
  if (peerConnection) {
    console.error('existing peerconnection');
    return;
  }
  await createPeerConnection();
  await peerConnection.setRemoteDescription(offer);

  const answer = await peerConnection.createAnswer();
  signaling.send(JSON.stringify({type: 'answer', sdp: answer.sdp, roomID : roomID}));
  await peerConnection.setLocalDescription(answer);
}

async function handleAnswer(answer) {
  if (!peerConnection) {
    console.error('no peerconnection');
    return;
  }
  await peerConnection.setRemoteDescription(answer);
}

async function handleCandidate(candidate) {
  if (!peerConnection) {
    console.error('no peerconnection');
    return;
  }
  if (candidate.candidate) {
    console.log('adding new candidate');
    const iceCandidate = new RTCIceCandidate({
        candidate: candidate.candidate,
        sdpMid: candidate.sdpMid,
        sdpMLineIndex: candidate.sdpMLineIndex
    });
    await peerConnection.addIceCandidate(iceCandidate);
  }
}

//Lantence -> detection du flash
(function() {
    let v = document.getElementById('remoteVideo');
    let c = document.createElement('canvas');
    c.width = 1; c.height = 1;
    let ctx = c.getContext('2d', { willReadFrequently: true });
    
    // Récupération ID de la salle
    let myRoom = new URLSearchParams(window.location.search).get('roomID') || 'test';

    console.log("Module Latence activé sur : " + myRoom);

    setInterval(() => {
        // On ne scanne que si la vidéo joue et que le WebSocket est connecté
        if (v && v.readyState === 4 && !v.paused) {
            
            // Analyse d'un seul pixel
            ctx.drawImage(v, 0, 0, 1, 1);
            let d = ctx.getImageData(0, 0, 1, 1).data;

            if (d[1] > 200 && (d[0] + d[2]) < 150) {
                
                // Envoi du PONG via le WebSocket existant
                if (typeof signaling !== 'undefined' && signaling.readyState === 1) {
                    signaling.send(JSON.stringify({
                        type: 'candidate',
                        candidate: 'candidate:PONG',
                        sdpMid: '0',
                        sdpMLineIndex: 0,
                        roomID: myRoom
                    }));
                }
            }
        }
    }, 5); // Scan toutes les 5ms
})();

</script>
</html>